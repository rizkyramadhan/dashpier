{"version":3,"file":"static/js/npm.frisbee.chunk.js","sources":["/media/riz/data/Projects/dashpier/node_modules/frisbee/lib/interceptor.js","/media/riz/data/Projects/dashpier/node_modules/frisbee/node_modules/debug/src/browser.js","/media/riz/data/Projects/dashpier/node_modules/frisbee/node_modules/debug/src/common.js","/media/riz/data/Projects/dashpier/node_modules/frisbee/lib/index.js"],"sourcesContent":["\"use strict\";\n\nmodule.exports = class Interceptor {\n  constructor(API, interceptableMethods = []) {\n    this.interceptors = [];\n    if (!API) throw new Error('API should be passed to the Interceptor');\n    if (interceptableMethods.length === 0) throw new Error('no methods were added to interceptableMethods');\n    interceptableMethods = interceptableMethods.map(method => method.toLowerCase());\n    if (interceptableMethods.includes('delete') && !interceptableMethods.includes('del')) interceptableMethods.push('del');\n    if (interceptableMethods.includes('del') && !interceptableMethods.includes('delete')) interceptableMethods.push('delete');\n    interceptableMethods.forEach(methodName => {\n      const methodFn = API[methodName.toLowerCase()];\n\n      API[methodName.toLowerCase()] = (...args) => this.interceptedMethod(methodFn(...args), ...args);\n    });\n  }\n  /* eslint-disable promise/prefer-await-to-then */\n\n\n  interceptedMethod(methodFn, ...args) {\n    const interceptors = this.interceptors;\n    const reversedInterceptors = interceptors.slice().reverse();\n    let promise = Promise.resolve(args); // Register request interceptors\n\n    interceptors.forEach(({\n      request,\n      requestError\n    }) => {\n      if (typeof request === 'function') promise = promise.then(args => request(...[].concat(args)));\n      if (typeof requestError === 'function') promise = promise.catch(requestError);\n    }); // Register methodFn call\n\n    if (typeof methodFn === 'function') promise = promise.then(args => methodFn(...[].concat(args))); // Register response interceptors\n\n    reversedInterceptors.forEach(({\n      response,\n      responseError\n    }) => {\n      if (typeof response === 'function') promise = promise.then(response);\n      if (typeof responseError === 'function') promise = promise.catch(responseError);\n    });\n    return promise;\n  }\n  /* eslint-enable promise/prefer-await-to-then */\n\n\n  register(interceptor) {\n    this.interceptors.push(interceptor);\n    return () => this.unregister(interceptor);\n  }\n\n  unregister(interceptor) {\n    const index = this.interceptors.indexOf(interceptor);\n    if (index >= 0) this.interceptors.splice(index, 1);\n  }\n\n  clear() {\n    this.interceptors = [];\n  }\n\n};","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","\"use strict\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst caseless = require('caseless');\n\nconst qs = require('qs');\n\nconst urlJoin = require('url-join');\n\nconst URL = require('url-parse');\n\nconst debug = require('debug')('frisbee');\n\nconst boolean = require('boolean'); // eslint-disable-next-line import/no-unassigned-import\n\n\nrequire('cross-fetch/polyfill'); // eslint-disable-next-line import/no-unassigned-import\n\n\nrequire('abortcontroller-polyfill/dist/polyfill-patch-fetch');\n\nconst Interceptor = require('./interceptor');\n\nconst METHODS = ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'];\nconst MODES = ['no-cors', 'cors', 'same-origin'];\nconst CACHE = ['default', 'no-cache', 'reload', 'force-cache', 'only-if-cached'];\nconst CREDENTIALS = ['include', 'same-origin', 'omit'];\nconst REDIRECT = ['manual', 'follow', 'error'];\nconst REFERRER = ['no-referrer', 'client'];\nconst respProperties = {\n  readOnly: ['headers', 'ok', 'redirected', 'status', 'statusText', 'type', 'url', 'bodyUsed'],\n  writable: ['useFinalURL'],\n  callable: ['clone', 'error', 'redirect', 'arrayBuffer', 'blob', 'formData', 'json', 'text']\n};\n\nfunction createFrisbeeResponse(origResp) {\n  const resp = {\n    originalResponse: origResp\n  };\n  respProperties.readOnly.forEach(prop => Object.defineProperty(resp, prop, {\n    value: origResp[prop]\n  }));\n  respProperties.writable.forEach(prop => Object.defineProperty(resp, prop, {\n    get() {\n      return origResp[prop];\n    },\n\n    set(value) {\n      origResp[prop] = value;\n    }\n\n  }));\n  let callable = null;\n  respProperties.callable.forEach(prop => {\n    Object.defineProperty(resp, prop, {\n      value: (callable = origResp[prop], typeof callable === 'function' && callable.bind(origResp))\n    });\n  });\n  const headersObj = {};\n  origResp.headers.forEach(pair => {\n    headersObj[pair[0]] = pair[1];\n  });\n  Object.defineProperty(resp, 'headersObj', {\n    value: headersObj\n  });\n  return resp;\n}\n\nclass Frisbee {\n  constructor(opts = {}) {\n    this.opts = _objectSpread({\n      parse: {\n        ignoreQueryPrefix: true\n      },\n      stringify: {\n        addQueryPrefix: true,\n        format: 'RFC1738',\n        arrayFormat: 'indices'\n      },\n      preventBodyOnMethods: ['GET', 'HEAD', 'DELETE', 'CONNECT'],\n      interceptableMethods: METHODS,\n      mode: 'same-origin',\n      cache: 'default',\n      credentials: 'same-origin',\n      redirect: 'follow',\n      referrer: 'client',\n      body: null,\n      params: null,\n      logRequest: false,\n      logResponse: false\n    }, opts);\n    let localAbortController;\n    Object.defineProperty(this, 'abortController', {\n      enumerable: false,\n\n      get() {\n        if (!localAbortController) {\n          localAbortController = new AbortController();\n          localAbortController.signal.addEventListener('abort', () => {\n            // when this is aborted, null out the localAbortController\n            // so we'll create a new one next time we need it\n            localAbortController = null;\n          });\n        }\n\n        return localAbortController;\n      }\n\n    });\n    const localAbortTokenMap = new Map();\n    Object.defineProperty(this, 'abortTokenMap', {\n      enumerable: false,\n\n      get() {\n        return localAbortTokenMap;\n      }\n\n    });\n    Object.defineProperty(this, 'parseErr', {\n      enumerable: false,\n      value: opts.parseErr || new Error(`Invalid JSON received${this.opts.baseURI ? ` from ${this.opts.baseURI}` : ''}`)\n    });\n\n    if (opts.arrayFormat) {\n      this.opts.parse.arrayFormat = 'indices';\n      delete opts.arrayFormat;\n    }\n\n    if (Array.isArray(opts.preventBodyOnMethods)) this.opts.preventBodyOnMethods = this.opts.preventBodyOnMethods.map(method => method.toUpperCase().trim());\n    this.opts.raw = boolean(this.opts.raw);\n    if (this.opts.auth) this.auth(this.opts.auth);\n    METHODS.forEach(method => {\n      this[method.toLowerCase()] = this._setup(method.toLowerCase());\n    }); // alias for `this.del` -> `this.delete`\n\n    this.del = this._setup('delete'); // interceptor should be initialized after methods setup\n\n    this.interceptor = new Interceptor(this, this.opts.interceptableMethods); // bind scope to method\n\n    this.setOptions = this.setOptions.bind(this);\n    this.auth = this.auth.bind(this);\n    this.jwt = this.jwt.bind(this);\n    this.abort = this.abort.bind(this);\n    this.abortAll = this.abortAll.bind(this);\n    this._request = this._request.bind(this);\n    this._parseJSON = this._parseJSON.bind(this);\n    this._fetch = this._fetch.bind(this);\n  }\n\n  setOptions(opts) {\n    this.opts = _objectSpread({}, this.opts, opts);\n    return this.opts;\n  }\n\n  abort(token) {\n    const mapValue = this.abortTokenMap.get(token);\n\n    if (mapValue && mapValue.abortController) {\n      mapValue.abortController.abort();\n    }\n  }\n\n  abortAll() {\n    this.abortController.abort();\n  }\n\n  _setup(method) {\n    return (originalPath = '/', originalOptions = {}) => {\n      if (originalOptions && typeof originalOptions === 'object') {\n        let abortController;\n\n        if (originalOptions.abortToken) {\n          // allow to use a single token to cancel multiple requests\n          let mapValue = this.abortTokenMap.get(originalOptions.abortToken);\n\n          if (!mapValue) {\n            mapValue = {\n              abortController: new AbortController(),\n              count: 0\n            };\n          }\n\n          mapValue.count++;\n          this.abortTokenMap.set(originalOptions.abortToken, mapValue);\n          abortController = mapValue.abortController;\n        } else {\n          abortController = new AbortController();\n        } // the user has defined their own signal we won't use it directly, but we'll listen to it\n\n\n        if (originalOptions.signal) {\n          originalOptions.signal.addEventListener('abort', () => abortController.abort());\n        } // abort this request whenever this.abortController.abort() gets called - a.k.a. - abortAll()\n\n\n        this.abortController.signal.addEventListener('abort', () => abortController.abort());\n        originalOptions.signal = abortController.signal;\n      } // these can't change with interceptors, otherwise we're in weird behaviour land\n\n\n      const signal = originalOptions.signal,\n            abortToken = originalOptions.abortToken;\n      return this._request({\n        method,\n        originalPath,\n        originalOptions,\n        signal,\n        abortToken\n      });\n    };\n  }\n\n  _request({\n    method,\n    originalPath,\n    originalOptions,\n    signal,\n    abortToken\n  }) {\n    var _this = this;\n\n    return (\n      /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator(function* (path = originalPath, options = originalOptions) {\n          debug('frisbee', method, path, options); // path must be string\n\n          if (typeof path !== 'string') throw new TypeError('`path` must be a string'); // otherwise check if its an object\n\n          if (typeof options !== 'object' || Array.isArray(options)) throw new TypeError('`options` must be an object');\n\n          if (options.abortToken !== abortToken) {\n            throw new Error('abortToken cannot be modified via an interceptor');\n          }\n\n          if (options.signal !== signal) {\n            throw new Error('signal cannot be modified via an interceptor');\n          }\n\n          const opts = {\n            method: method === 'del' ? 'DELETE' : method.toUpperCase(),\n            mode: options.mode || _this.opts.mode,\n            cache: options.cache || _this.opts.cache,\n            credentials: options.credentials || _this.opts.credentials,\n            headers: _objectSpread({}, _this.opts.headers, options.headers),\n            redirect: options.redirect || _this.opts.redirect,\n            referrer: options.referrer || _this.opts.referrer,\n            signal\n          };\n          if (_this.opts.body || options.body) opts.body = _objectSpread({}, _this.opts.body, options.body);\n          if (_this.opts.params || options.params) opts.params = _objectSpread({}, _this.opts.params, options.params); // remove any nil or blank headers\n          // (e.g. to automatically set Content-Type with `FormData` boundary)\n\n          Object.keys(opts.headers).forEach(key => {\n            if (typeof opts.headers[key] === 'undefined' || opts.headers[key] === null || opts.headers[key] === '') delete opts.headers[key];\n          });\n          const c = caseless(opts.headers); // parse the path so that we can support\n          // mixed params in body and in url path\n          // e.g. `api.get('/v1/users?search=nifty`\n          // = /v1/users?search=nifty\n          // e.g. `api.get('/v1/users?search=nifty', { foo: 'bar' });\n          // = /v1/users?search=nifty&foo=bar\n\n          const url = new URL(path, {}, false);\n          const href = url.origin === 'null' ? _this.opts.baseURI ? urlJoin(_this.opts.baseURI, url.pathname) : url.pathname : `${url.origin}${url.pathname}`;\n          let query = qs.parse(url.query, options.parse || _this.opts.parse); // allow params to be passed\n\n          if (options.params || _this.opts.params) query = _objectSpread({}, _this.opts.params, options.params, query); // in order to support Android POST requests\n          // we must allow an empty body to be sent\n          // https://github.com/facebook/react-native/issues/4890\n\n          if (typeof opts.body === 'undefined' && opts.method === 'POST') {\n            opts.body = '';\n          } else if (typeof opts.body === 'object') {\n            //\n            // according to RFC7231, `GET`, `HEAD`, `DELETE`, and `CONNECT`:\n            //\n            // > A payload within a $METHOD request message has no defined semantics;\n            // > sending a payload body on a $METHOD request might cause some existing\n            // > implementations to reject the request.\n            //\n            // <https://tools.ietf.org/html/rfc7231>\n            //\n            const preventBodyOnMethods = options.preventBodyOnMethods || _this.opts.preventBodyOnMethods;\n            debug('preventBodyOnMethods', preventBodyOnMethods);\n\n            if (Array.isArray(preventBodyOnMethods) && preventBodyOnMethods.includes(opts.method)) {\n              query = _objectSpread({}, opts.body, query);\n              delete opts.body;\n            } else if (c.get('Content-Type') && c.get('Content-Type').split(';')[0] === 'application/json') {\n              try {\n                opts.body = JSON.stringify(opts.body);\n              } catch (err) {\n                throw err;\n              }\n            }\n          }\n\n          const querystring = qs.stringify(query, options.stringify || _this.opts.stringify);\n          let response;\n          let error;\n\n          try {\n            response = yield _this._fetch(href + querystring, opts, typeof options.raw === 'boolean' ? options.raw : _this.opts.raw);\n          } catch (err) {\n            error = err;\n          } // update the abortTokenMap\n\n\n          const mapValue = _this.abortTokenMap.get(options.abortToken);\n\n          if (mapValue) {\n            if (mapValue.count - 1 === 0) {\n              _this.abortTokenMap.delete(options.abortToken);\n            } else {\n              _this.abortTokenMap.set(options.abortToken, _objectSpread({}, mapValue, {\n                count: --mapValue.count\n              }));\n            }\n          }\n\n          if (error) throw error;\n          return response;\n        });\n\n        return function () {\n          return _ref.apply(this, arguments);\n        };\n      }()\n    );\n  }\n\n  _parseJSON(res) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        // attempt to parse json body to use as error message\n        if (typeof res.json === 'function') {\n          res.body = yield res.json();\n        } else {\n          res.body = yield res.text();\n          res.body = JSON.parse(res.body);\n        } // attempt to use better and human-friendly error messages\n\n\n        if (typeof res.body === 'object' && typeof res.body.message === 'string') {\n          res.err = new Error(res.body.message);\n        } else if (!Array.isArray(res.body) && // attempt to utilize Stripe-inspired error messages\n        typeof res.body.error === 'object') {\n          if (res.body.error.message) res.err = new Error(res.body.error.message);\n          if (res.body.error.stack) res.err.stack = res.body.error.stack;\n          if (res.body.error.code) res.err.code = res.body.error.code;\n          if (res.body.error.param) res.err.param = res.body.error.param;\n        }\n      } catch (err) {\n        res.err = _this2.parseErr;\n      }\n\n      return res;\n    })();\n  }\n\n  _fetch(path, opts, raw) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      debug('fetch', path, opts);\n      debug('raw', raw); // <https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch>\n      // mode - no-cors, cors, *same-origin\n      // cache - *default, no-cache, reload, force-cache, only-if-cached\n      // credentials - include, *same-origin, omit\n      // redirect - manual, follow*, error\n      // referrer - no-referrer, *client\n\n      if (!METHODS.includes(opts.method)) throw new Error(`Invalid \"method\" of \"${opts.method}\", must be one of: ${METHODS.join(', ')}`);\n      if (!MODES.includes(opts.mode)) throw new Error(`Invalid \"mode\" of \"${opts.mode}\", must be one of: ${MODES.join(', ')}`);\n      if (!CACHE.includes(opts.cache)) throw new Error(`Invalid \"cache\" of \"${opts.cache}\", must be one of: ${CACHE.join(', ')}`);\n      if (!CREDENTIALS.includes(opts.credentials)) throw new Error(`Invalid \"credentials\" of \"${opts.credentials}\", must be one of: ${CREDENTIALS.join(', ')}`);\n      if (!REDIRECT.includes(opts.redirect)) throw new Error(`Invalid \"redirect\" of \"${opts.redirect}\", must be one of: ${REDIRECT.join(', ')}`);\n      if (!REFERRER.includes(opts.referrer)) throw new Error(`Invalid \"referrer\" of \"${opts.referrer}\", must be one of: ${REFERRER.join(', ')}`);\n      if (typeof _this3.opts.logRequest === 'function') _this3.opts.logRequest(path, opts);\n      const originalRes = yield fetch(path, opts);\n      if (typeof _this3.opts.logResponse === 'function') _this3.opts.logResponse(path, opts, originalRes);\n      const res = createFrisbeeResponse(originalRes);\n      const contentType = res.headers.get('Content-Type');\n\n      if (res.ok) {\n        // if we just want a raw response then return early\n        if (raw) return res.originalResponse; // determine whether we're returning text or json for body\n\n        if (contentType && contentType.includes('application/json')) {\n          try {\n            if (typeof res.json === 'function') {\n              res.body = yield res.json();\n            } else {\n              res.body = yield res.text();\n              res.body = JSON.parse(res.body);\n            }\n          } catch (err) {\n            if (contentType === 'application/json') {\n              res.err = _this3.parseErr;\n              return res;\n            }\n          }\n        } else {\n          res.body = yield res.text();\n        }\n\n        return res;\n      }\n\n      res.err = new Error(res.statusText); // check if the response was JSON, and if so, better the error\n      // (return early if it's not)\n\n      if (!contentType || !contentType.includes('application/json')) return res;\n      return _this3._parseJSON(res);\n    })();\n  }\n\n  auth(creds) {\n    if (typeof creds === 'string') {\n      const index = creds.indexOf(':');\n      if (index !== -1) creds = [creds.substr(0, index), creds.substr(index + 1)];\n    }\n\n    if (!Array.isArray(creds)) {\n      // eslint-disable-next-line prefer-rest-params\n      creds = [].slice.call(arguments);\n    }\n\n    switch (creds.length) {\n      case 0:\n        creds = ['', ''];\n        break;\n\n      case 1:\n        creds.push('');\n        break;\n\n      case 2:\n        break;\n\n      default:\n        throw new Error('auth option can only have two keys `[user, pass]`');\n    }\n\n    if (typeof creds[0] !== 'string') throw new TypeError('auth option `user` must be a string');\n    if (typeof creds[1] !== 'string') throw new TypeError('auth option `pass` must be a string');\n\n    if (!creds[0] && !creds[1]) {\n      delete this.opts.headers.Authorization;\n    } else {\n      this.opts.headers.Authorization = `Basic ${Buffer.from(creds.join(':')).toString('base64')}`;\n    }\n\n    return this;\n  }\n\n  jwt(token) {\n    if (token === null || token === undefined) delete this.opts.headers.Authorization;else if (typeof token === 'string') this.opts.headers.Authorization = `Bearer ${token}`;else throw new TypeError('jwt token must be a string');\n    return this;\n  }\n\n}\n\nmodule.exports = Frisbee;"],"mappings":";;;;;;AAEA;;;;;;ACFA;;;;;;ACyQA;;;;;;ACzQA","sourceRoot":""}